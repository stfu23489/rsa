const encoderAlphabet = "聿堡摳誂逮愐瀼向餤璊衝趠蠋鈳篡肽廟孰豺廔尥軹戕齹逞疽墟蜷弟騮奸尟全鐻靠轠枋嗛縛腺嶴籋墩烘紽蠡栢眢坪魶管霿蛗葽稊砟桲掄衙曬呴瘨媾禋柜綱駱贜賵洛舅酤卮嗟辣會絍隅枑渟饙犺抒宛奚畎黕郣囫剋晻鮞糪贕夏迺崙耔蠱眇徨蜉妸牁寄啡灞頸縩鴻邅葺潤喧躁脝荇窮瓿蜣嘧霆钁寥燡希食皺傃洊潦鶚驩舺嚀旼杙鉸莖慊瘱拯呤籧呔癩輹淘蟇茨揕癱仿鏐潢萯峩拉昶齦躉捅貏膞殳塑蝔楖派彈熲銅菙颶家犨綯紅訧寤倸倏亓騖蟯棊囁鈁哄牉琨岝炊隗靦蒹狉矊輴茝别難藑蠊冱肜皇鷩菓淋甘鵌睟榛滕嚎級氊蒱奧疣瞼怎饅滓唏瘡邋蹙齯昭畝駑榻雷淙珩粉學獬益纘痱跇仇羰鞴蟆芫圓俜卹罛畷饆奢埕瀰咦銱壯厖蚨燉選禛㛂蚹呷睿碻鈃阨苴扅檎趨丏劍以蝜簜蟳蒩諞蝕僗榱杬生渺捋暌篩儇雌蟷央剨甪敧纛樿惛翽迭鑾匼淖甹緎褭懅韗酮案襵詙矻燒邑魁悽廵蠶艽閌張偉瘘返餿郎餩饕鎂眹匀瘋訥朗嵐覆觳槩菇硤際帖樑敫有羝殃反丿諦衲乩宂度媬蝀閭皎弘惌㓦遭棬室艤朏胾舂坂往葚剪韍磣攞滀馭鉺慢肅幹莝帚阻峿瓦寬值跺疚酋緅謅魭雀慵嗚劉燮蝐峋踢㥏泫啷蜈桹滵渴鯁焗衡驚蚇耄耀刀襚垺鮋涮忽欒鷫鍊琪敷薑啞岑蛑傔鬺墨蹐鯿頏苗妓財蟈熒衊艎倔露犀俛膿佾鄞鈔潁評紿髠域埛檕鄗盡縕歡鎔懆貆刻瘇容熺菠好胯朴軑滏鏘釱蟮廨齺媞麩儐樓穌昂搷沬瑑奫憧陂曰浼剉虆逍刮噍尷壽蘊鞮鼓咏嚓璐藣鵊涊芪瀾秆抄徉噗湫簣堮懁陋惶釕蠲韅踶漫穫猊愛蛋潾觔屯鍵鬫唚縫驪嫜爵鯀臆攉寂瞥欶鐧魊夊頇罭磴釿忙蛬鐇愜別呂顙順璈岐攧睆隴艮酵排伸鬯憸路宄糶堧櫜眨甩球跐莫灘膜憋佤氰坰近簀渾攪鄸醥嗿榴俇訶窄淄坶闋鋁瓓痯胖罬覼薌駪咧監豆亂迷諢拗捶賅逯檸渳魨檞顒餓剩蔪簰俚貘詫亠粱漓孴蓖瞫齖繸鉏崧叨堙毧狴瘉鏁咢踞諸擀鑀獶褖纓磲撅甃葒榕酷燐圌蟛佴忑譏佰讆簿榖虺机蔥颼醞筱吐兗浡禧嶓睩詞誣粵顑晼虱邥薊摽矽嗆韃梩玢蛓讒煉昬雒阿壩漩葄椒漂律礮狨芝輙噫直愕筧惸釷籮鍘鶴鶼阯汜銨乖忣藇諄晞笯鉢綻攔鍥冉泜嗦乣滌測晰館鐵煌槔蘄焜頍才默妢摴鸂筯落嘒瞷詻綫匵兇螲窊靜鼱訊緯甆嶪持層鞶宬屑頄逾苙墓覦柏試闒絅雖抏郢韠窋冑猿鮐蚊粗飪魋聞氘媵略嗉畏厪帢赯沂筈耋祼毖醵輾窱掭鵲狂煥礨畺螂韐綸麰傴慘飉憑諵蠖胰甋娠縟襫捺惕蟿陶媻揟礦齆徥舡嶼竊獉篥搋侁六彧馨襂車淡鏦跗世牓浣集騫穩鴷鎵襆休胂泝頭匐颿籝筭犯仙蓆楣臞妥鄰魴料翶崇咬絻塋焐卼簪濡眕藭促闕腜剔茉痀雅恢窻呫醍陵袠檖圠鱞痎槃側鷓蜎踣吮剒哷要塘莒樀鬆茴圖飰嗄搌舔窟蓀睮閛鱉虬吠滎貶飋黂儍枌邃稈驗下咈溏泖莆勻斕梢銥駛蛀鞄偏俯瘸偃瘯聾系庭呥婦琳罇桋候盛鎴疊樴踦耜沐澭擭鴽妬汞斥滷鄔驈澇嫗揍牝顠酊寯菟潑邢茪嗯笲治蔉猺需眾螌迆岡頰填廕飆伀鴾象鮟萎鷂攣例邛漚暗芎淠啥鱒蛼奭騉撽濿杏逡椰笄誏覕燼姺睦豎溉羶忍廚想閻顣協祗徭參蹬蛛轚抃焄恆聊旮窆矔皫櫌幅憊鬖鉞棐姙諤嘈菅祧銑藙月兮殯喓盎帑蘼沕造蜍驉穽劌扉懿獼鴟劇鋮艦賷抖胎娓眠緦潠疑鼃黑秩劾鑞憔騷抛韙版萹嘶葖湧讇煦忠磉樊嘕萊丌莂笏慱漠嬾術虒黿祆之玥絣聱膋腡穟縁敵二正方磬吃綎腭騀餠攭姍洋韻穉具濰舚訪鵩呆絏梗襒媺撙隼誒蒼泠尽夸婼謙驥弧脇徜搓斯衄琛疹屍穢隣斷州栳嵞堩癡嬌款筥橛玭櫂玨芧瞧灋礓蓩袞起笢次莙饟述藿咥篦漣磽挴搯膚力掯閡鬧粳俗扺噱燴鰜綅孓蕅觶殤飣熹笮雰粲頴缹鴿彔粺骷澹億娑哳睬逕鄧線曡帶嗽猍馝匣渹歸尌鄀痺畸又苳囋厝章癘熬束喘丳油囡宙漆粔第蘢釢橧蠼每嶡已裁潞蓓霉汭氆脤祡逵繜疆弭呿萴桑矬揞羨艷釆擻儱褙千餦鈞硇踁遹崆麟髩镼摸豶坼挱忨盻渭鯶癸劑霢己咍茵勞薈琚狸謂嗤諷㕒羹隊爛薏棧悰鼖瞬澀蚱蠣殈孔趲羌羽澩傭勸挑慈鞣鸝齮毯朒丕姦紫鱄繚丟閿萱汰剃屬蠵珙巡刜椿敦縪搠坏騠縠奶泚肋洺曆覬停氀韌轕鎛樺野獗遰忲碞掇糉拆柰捷齶兵門京鐙作姪琖跚輦洧戶飱牢蝓掁亡荀蜋客薛嘗骸瘍茺緇跩蝮滋緜羵堯皞葬撂豨邾瘲娉捘翦鑹嫂蹦雍郊餚犄帟侚庵籔荂賒晁頻義胠越咫削畀邂禦棷盉袂器倆忕廷邿掂廋畇埻鉒蓑枯棓檳騙睋痍瑰病封眊灄偈鶢麇黈扑吹徯恐杶頲洽碭隉駼仚子瀨刱芽痔埠氃攩鞈朾噲壠泡襭週輊䫄庣歘仗軸痏緞鐃僓撦壬膩堽鬡傒纜褯郃乏緩苞口押白譬仵眉佒嘯侮滺氿啻繮濼猩窞幄仨矧安帙擿溔膊魃攏梵機妲蠃鑣刁龠愨塭蘆銀荍佝蛞私掙鷞維慣邀撒瀟坦縝劬煩癮担檑譟焉棋涌簆挓儃技碲棰蔟靁棟糊蚤釙啣舨屭怫煜韁讜旂鰵駻遲鋪嗷箏壓鄐蟻醛忌簋骻玁斌理浞嫉晨怹塙郰悕厥燋鱓峰蟪巍樵奐笸剞婢光銹褸罽孟俾劃潸樝叒郔看鰭腍嫟閏覿啢姞欞揔備欥濩袜饔槮鈧榶絜褳嗊屩洎淟男軻也艭簺柯鍑搗麂哦慷宓謹僣庚澌錒勛㵝漲勇綪鐔駏喃曠響源胉怱袀嶮禖焚剴栗黭濇懃蒿嵩氏薠勱鬮鱧甡幺潟髶赤挺訇掔智任症卷愠耶萵纖贊嘁挃袾惑艅敶罦樅進繃償錯屈鴛狟隸鄳鄴筍樗緱廳屜誨稜墝芺敓塗舕爻趫鷸礁籑鏑息雜党綦蓏僛猫沘擗嬖刌蜼鴴璃涼模蝥猞夂姨埧棃淌靺蝠婺槿逩踸酧幸景橠賢蝻整胃嘍臺愷腮鰥岷妮窐葛軍鄲酹惎琱染扃烷坻癹炫衣綝逿哉哆秖悸柘旐搘熄僵註握虗舜邲琫胛固躊黝駍弛酒韔潰幷翹黧斶歙戳輷貓繙蟑鼴萑妗珈主部鵕榾匈懨翥衋傺漾萆冬犆畤旻罌熠戧撥予蹪溺歿廖蕾朮琇臉濕踳閞萩丸籪人稙柶竱各廄叵虀卑螅碉袡閘驄班箒酶綀它賕汸屣閾悉嚱占綟杳帤媍總闔股製赶涴傅啶偭湍鈒穗纕簽艉墻芘臯喀柧大籃畜蜇拭嘬崱嬲瑋儚陰堂欑幈而楚黴獺靂箱暖螭詄飾示蜊挹巵姌蓊戔氄罐童臝茍宦愍蛇豁倮瓅省聒巑槌穠嘏旱囑篆隙李釦榑紝攘鰣冂覶抌擩獌蘦湜絝鸛蜡澤彡滾緶菁裸繇妒拋斧姤錸鍋啅袋茆汶胦鬃券慞笆嚵禱樠鍮倗椎棨瑗獒碡煠匏岹龑翨剖脩豌夥蝦惜蚢矓並荽裻躣扠麗秧蒯礉裱懲捫纑舞盅嫋寘嘔癟莨缸儀蟄纇歗楫蜚椷癥褘娥滑懼搐汍跪旴劘麌劭抬雘鶡迹滃啵功旃崽驃畬鹺虎鑭腫艄勳蒍鷹頞鄜袄郴蜄澗婭鄣鞪戇袱簎烺鞿睗缿灺蠉氪囊犽江芬驁懻芼黜鬌黻譜遊獻勠當确徙達磾欠祇嚐教犫阱慌辞趵洚中卣摶癇滈餺嬋礌鎬縲茭峪靾瞪狳庸棜盔垔螯驏渙驂渰蹳熔曇鬍鰉顇鵃售膱折嬡鴞渚鐓鬚輛剚英詭薩洞截湖件鞵咸鼠儁完棍仞迍拴瓏憒軏讌藪德哂鰼瑁鐋焊屼操蚩呎徒沸瀍孼殑桮鏗馳繹瀋嚧斖軘鬣侞柳戍榦泌珊顱傚襞祫可溷擷袖拷疾鰹暵捃喤悌鞻核覥舸踅歷肫燭駹腌淫珞飇咽或澶曨硼杘蜮唸餉簉釓儒呪焠禡執鵜軱輐睎酌黶萰虙硎酈躲隹恌蓫蒒效杵貒鶋戹墅謬痢觸澉枕矉剜沚鰂偁杠猱飢穜俘狼淼篣邦鋒醬瑜嗣匙鰷帔屄漬褶鋰跤拿辭藺冰蝣屝即嵋仁沄荷如鳶犖巳澒狫爟彊樟陷輜眈麾氅扐廧癆冶幩烤耍悴微黨笈簸廜滮醐阬冼誤墯睄米悶屆瘓橚徹盤氙徽箠詶柵靄屁賁纀掤沓康頡探檄貊芃半絇脛喏鵀蛩擧序踡囚瞚邇愚鞃滹毗秎糴谹妐工魘嗩禚待泙塹庄謞畢襾貞苛彪司髒鄏髲皪臤鯛桐峯縱構琅蝴賦骴頯臌皰蛐酁砰避揫瘭馬菻翢氣噬拜瘕朕授堪栓濁槽掌桄筆槱殂皷澄鄇洸秋漊禁嫘鷊猲茗夜婞暹駿蘙鋋耞壟鷗旓朽颭壢阪惰涇克憹嵁鴈催巘虣幣鰻與荴蔬陴灊岧痃釾紜手硒太唶羔硭綣奏窸硯砦伋膳諆舷孱滬芚翊朔味鮨繐膘橙彛歜糙韝蕣踴蔤赭幬齕瑣蹁捏譚心駮忮冢根山嬤捵菔愴俞懌孃芩嶀硝珵帛鎡灶媢蘀彤燄氌軥習珠喌挾篘立菜剷臼甔礎喝怢翎悟昳捍鶊瓶訏璅遳妖溼堠洭丞穀駘媚棄蕺唅覽遑曀澂厓簠鰮茌紒邐翟蕎隱鞓籺瘦跆聝侜泓救濛陡饌螳藋繒楯鏃熯較倫缽槍茇戴聶秠胵蘠臘軼侶脡泣襌厜嗾瞽鬉衛渥騸蚳亍麈閫擋尬垕怭囅荸岋僆稾厠惵擦奉暍鞨渡籛啓扂瘞酉瑟澦偊嘓魑綌鴒受妺鎢畽瞟茄營宎創員窪蛾壞韡遡麯屐醋妃藂頗豉吋冠笨踊苾襤獅蒟袈刨侹搰趴攠嫮獠菆醫齔嬴炔鯠馞饝窿拫庌斫弰鵁詘歉箴姓殉點傍倜衽區牌幰譔悃衮跴齵漁瑾繩妎未鉶鷧蒞曾掘冲冥覯鈮屘仲籲盦鬭佺灼雙垣遂轎夬浮駓緧蜌黰提汪斗恰娜洴鏵蔏瑪汾糸傀摯漳痤蟀荵靼驎蘧鱇鸏赸謄磔筠糯蛟醇杇苕泪櫺摃睨凍實游懋懸旎癬壎扛睅迪俏岳麀陏喟趾划遇綉舒歑饊港鐺侲垃剫鵮鍳快開筳蕙飀號撆醓蹅喳蜓淹凋寇礴結曲鍠署斡新个掆拼鷕投蚌鑿爝札憱弃橑筢裟炕攛襢鱍虩禨偟糱煽齾汆皮錧悍擢穎岵脹佯眯艱蕡茼雥儴牸脢旗聯蜯腳付蝃鷖錠璵嶰庫崖皋倓繕噔嚄聖蜢妯槬勢潏构傜欄閎磁髏割劓搜齏憎薪津晜掞捭貲癃匽倭崓圇柣恂怩邱負簑銛争訛孤茬瓖郼寃脆汏懶髂憨卿斨改鰈蝖鯷睢唧躡搨蹧攖籉犁胥嚮痝雁詿餟歧幢蝙圭饜瀆莕樁險馥短姊琴十俎鵡骯鷲捆弗魈笐颱醊脧鯪毡圃圾糜乂蓋邪鋣碏厔魦絿廬印姻侔薙鸑僭幞媮靶譖成的鮎蛣倦荑硜燠砒嗡椹讙檛絛杼璲餑扆漵膺岩舌雝餵戌悢鉕庋倞鞾拐八振絕萐戩彠鏹羆蠁楸于箜觴酯繳哿枷噉恿殜炤缺偕騂濆虫假濘崔擅荎醚烙墜疙熳庀彼汎愎唫咿枇淰板蛤䥈肉鞚縴漿混剮嶁曷傌搎媱副蠏鰾菂憖坡卅倘索鈑轖齇垗荓鄍襠倡甎侃藐譴矎暇池役橜饉朦潎戀傖梒搳帽笫闐蹞菡怐煙噩芍甑襖砫踐斑飁因凇葍嗌浹嫕扯得做贗壜挈撫塼叱哰辨膍麴羿籓磺仟踱赩糖疔甭寒條茳語侑鰿慍匴箍腔㲪嗔用蔚瑒桀綢慫崡賄鉛柬賚墠裳偩鉚碴勒唲餘珏襡椗咷吪艓蹕褽僉酅灰皖籟愣鰕鄉葶咪吩鶩蘾吶懺經瀇隩柚鏈颯幟邽胔摠搏危囝眶慲躩忖嗈靆螈蹩巿夨撈婿倉砆浪蕊麄閶愊黛鄹忤㶁萬尉莔餪鷟涎訞玼躠壝蒴鍭蒨干忿肓欝盭磌曦淚領猶藤鮅籐僑殖棹姹礩軒曅茫粟卌毫票噙斀脬榣兒揣栔臅止觖瓌廥氯甍猋穰足窩褫偷猒嗑數橫縓絆泬䰐湝啤藳狶揄沿莉鈍鍺恒柴蕑錆映蓳鍍紀霄譾鱠礽褔練梲襃朣鯗叶摻鼒髫殞磈紺幻睃爊櫃毾尺匄毬諗疿櫰琰溚宋馹罳髖蜞襜証逗閬遠蔔霏櫱拑騬自唈芸馴玈盒牿灝蛁膃迤梧叡利郁錐仄衎饛筏殗枴撰嘹蝳咡匸菽鷥喪堞羱跧䰰剄蹮斝怛詆類刄妍耆嚙妙攟啁裒王庇爸竪鏙彷袷姿逝玉縉謾霹帣鍉瑊諳洲翀毛輅陀淴爾耨斤盂鮑漅囮賫珂錮訄筊囃軺喲唔嫭嘑鍔漉長訝雇儿粢飜符型稍裴猴話島湮蟭儘靈比鉗玠肕嗥貾攙嚆澍披遜薺湅咱捻耗婬筷沙躋皂缾輓薶釔葦愓圈瓞燥孺憲鯓孿胹凑煻渠拽汊辜壕艴曳吧凹唓囿琭尻麕櫫紡永毆儈軬表豊廛囷穛醭鷾許爁繅牲殿紱鸜吆斜暈釣臿疲黲鄢鐳宿褻鱖麃靮吷泰謦覊愁庳嚷胏皴羢簷憙朝咨筤墀槁怍屹跬猝蠔狺襣鑢貍躑畔冣鳳蹇侗驦龐傲饡拔黯照三瓬炘鑵誇貫鴣肭誆矐醮蔧鬴床蜂估鄯轒綑姘瘤昵恝莊再箋午他鄱攕㲯犵緊聰齚卲榭唁酇稰吵賡檗箎嗓戤吁蚕瞞黽抉蓽謟蔇誻狄閈腤箝鬑膈睠儩神齜瑀狹閹穅絡斛晾礄駟頵灖噶猛磞僔窒箐瞤箇怖書餫柅湛消柱遍湉迨阜洿交讖甲篠剕稀西閟坌噆琍敻鱣妁獸鹽廊鯇嘟悝辰縋羋覡蒙崐兢郿琦犛銍嬸屢礙磨嘲寡牆苔榆緡琶殙韘鍅碟欺攜沏沷竭垌韂騏蝤囉瘳喻洄躍佌悛嚼棚睏推菌堁殀齒埌唳簙勖商艸秕紆斁倀閧嚾登肱巒溠蜙戄巹臠賈聽摝絎胇栙倨址斸訢專偯腹蘘爓躂蚶迄身釅溜皜幎溘呸年宀咚溫鍬啼昜采鏤腕邡郡請搭急嫥矁醟鐎鶺麥蜤同胱俶篁貽穈鱻庮樹惆櫟損睺搛覜塓璠鼎婥聲福眩揉傷霙睡碔曛云葟烴惘悻龤搡歹鮦扮鋌娩酐紩澣苦砵敔嬝渲蚿醡擫咵郫鏮痠禪釂裌膷蠓疒轍湱夢姏牋倬轝蜘意獮唬馯袛腸偺友唗傘少算虛連蟶暠遽郝蕤鄘飡煢夲赬謊誥蹜炯鴃顓棉囂眡瘣戭峙篚竑"

const _standardBase64Chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

const _standardCharToInt = (() => {
    const map = {};
    for (let i = 0; i < _standardBase64Chars.length; i++) {
        map[_standardBase64Chars[i]] = i;
    }
    return map;
})();

function encodeBase64ToCustom(base64String, customAlphabet) {
    if (customAlphabet.length !== 4096) {
        console.warn(`Warning: Custom alphabet length is ${customAlphabet.length}, expected 4096.`);
    }

    // Remove padding for consistent pair processing if it exists, but process the raw Base64 characters.
    const cleanBase64String = base64String.replace(/=+$/, '');

    const mappedResult = [];
    // Process the base64 string in pairs of characters
    for (let i = 0; i < cleanBase64String.length; i += 2) {
        if (i + 1 < cleanBase64String.length) {
            // Process a pair of characters
            const char1 = cleanBase64String[i];
            const char2 = cleanBase64String[i + 1];

            const value1 = _standardCharToInt[char1];
            const value2 = _standardCharToInt[char2];

            if (value1 === undefined || value2 === undefined) {
                console.error(`Error: Invalid base64 character encountered in pair '${char1}${char2}'. Skipping this pair.`);
                continue;
            }

            const combined12BitValue = (value1 << 6) | value2;

            if (combined12BitValue >= 0 && combined12BitValue < customAlphabet.length) {
                mappedResult.push(customAlphabet[combined12BitValue]);
            } else {
                console.warn(`Warning: Combined 12-bit value ${combined12BitValue} is out of bounds for the custom alphabet. Skipping.`);
            }
        } else {
            // Handle the single remaining character (odd number of base64 characters)
            // Append the raw standard Base64 character directly.
            mappedResult.push(cleanBase64String[i]);
        }
    }
    return mappedResult.join("");
}

function decodeCustomToBase64(mappedString, customAlphabet) {
    if (customAlphabet.length !== 4096) {
        console.warn(`Warning: Custom alphabet length is ${customAlphabet.length}, expected 4096 for decoding.`);
    }

    // Create an inverse mapping from custom alphabet char to its 12-bit value
    const customCharToInt = {};
    for (let i = 0; i < customAlphabet.length; i++) {
        customCharToInt[customAlphabet[i]] = i;
    }

    // Step 1: Decode characters from the custom alphabet back to standard Base64
    const decodedStandardChars = [];
    for (const charFromMapped of mappedString) {
        const combined12BitValue = customCharToInt[charFromMapped];

        if (combined12BitValue === undefined) {
            // If the character is not in the custom alphabet, assume it's a raw standard Base64 character
            if (_standardCharToInt[charFromMapped] !== undefined) {
                decodedStandardChars.push(charFromMapped); // Add the raw character
            } else {
                console.error(`Error: Character '${charFromMapped}' not found in custom alphabet or standard Base64 set. Skipping.`);
            }
        } else {
            // If the character is from the custom alphabet, decode it into two 6-bit values
            const value1 = (combined12BitValue >> 6) & 0x3F;
            const value2 = (combined12BitValue) & 0x3F;

            if (value1 >= 0 && value1 < 64 && value2 >= 0 && value2 < 64) {
                decodedStandardChars.push(_standardBase64Chars[value1]);
                decodedStandardChars.push(_standardBase64Chars[value2]);
            } else {
                console.error(`Error: Invalid 6-bit value derived (${value1}, ${value2}). Skipping character.`);
            }
        }
    }
    let standardBase64String = decodedStandardChars.join("");

    // Step 2: Ensure correct padding for standard Base64
    while (standardBase64String.length % 4 !== 0) {
        standardBase64String += '=';
    }
    return standardBase64String;
}

// Tab functionality
function switchTab(tabId, clickedButton) {
    // Hide all tab contents
    document.querySelectorAll('.tab-content').forEach(content => {
        content.classList.remove('active');
    });

    // Remove active class from all tab buttons
    document.querySelectorAll('.tab-button').forEach(button => {
        button.classList.remove('active', 'border-blue-600');
        button.classList.add('border-transparent');
    });

    // Show selected tab content
    document.getElementById(tabId).classList.add('active');

    // Add active class to clicked button
    clickedButton.classList.add('active', 'border-blue-600');
    clickedButton.classList.remove('border-transparent');
}

// Toggle password visibility
function togglePasswordVisibility(inputId) {
    const input = document.getElementById(inputId);
    const button = input.nextElementSibling;

    if (input.type === 'password') {
        input.type = 'text';
        button.innerHTML = '<i class="fas fa-eye-slash"></i>';
    } else {
        input.type = 'password';
        button.innerHTML = '<i class="fas fa-eye"></i>';
    }
}

// Utility function to show a "Done" state for a button
function showDoneState(button, originalHTML) {
    button.disabled = true;
    button.innerHTML = '<i class="fas fa-check-circle mr-2"></i> Done';
    setTimeout(() => {
        button.innerHTML = originalHTML;
        button.disabled = false;
    }, 1500); // 1.5 seconds
}

// UTILS
// Converts ArrayBuffer to Base64 string
function ab2b64(buf) {
    const bytes = new Uint8Array(buf);
    let binary = '';
    for(let b of bytes) binary += String.fromCharCode(b);
    return btoa(binary);
}

// Converts Base64 string to ArrayBuffer
function b642ab(str) {
    const binary = atob(str);
    const len = binary.length;
    const buf = new Uint8Array(len);
    for(let i=0; i<len; i++) buf[i] = binary.charCodeAt(i);
    return buf.buffer;
}

// Concatenates multiple Uint8Arrays into a single one
function concatArrays(...arrays) {
    let totalLength = arrays.reduce((acc, arr) => acc + arr.length, 0);
    let result = new Uint8Array(totalLength);
    let offset = 0;
    for(let arr of arrays){
        result.set(arr, offset);
        offset += arr.length;
    }
    return result;
}

// Removes PEM header/footer and all whitespace
function stripPemHeaderFooter(pem) {
    return pem.replace(/-----BEGIN [^-]+-----/, '')
            .replace(/-----END [^-]+-----/, '')
            .replace(/\s+/g, '');
}

// Converts PEM format to raw Base64 string
function pemToBase64(pem) {
    return stripPemHeaderFooter(pem);
}

// Formats a raw Base64 string into PEM format
function toPem(base64, label) {
    let formatted = base64.match(/.{1,64}/g).join('\n');
    return `-----BEGIN ${label}-----\n${formatted}\n-----END ${label}-----`;
}

// Imports a public key from PEM format for encryption
async function importPublicKeyFromPem(pem) {
    const b64 = pemToBase64(pem);
    const spki = b642ab(b64);
    return crypto.subtle.importKey('spki', spki, {name:'RSA-OAEP', hash:'SHA-256'}, true, ['encrypt']);
}

// Imports a private key from PEM format for decryption
async function importPrivateKeyFromPem(pem) {
    const b64 = pemToBase64(pem);
    const pkcs8 = b642ab(b64);
    return crypto.subtle.importKey('pkcs8', pkcs8, {name:'RSA-OAEP', hash:'SHA-256'}, true, ['decrypt']);
}

// Imports a public key from PEM format for signature verification
async function importSignPublicKeyFromPem(pem) {
    const b64 = pemToBase64(pem);
    const spki = b642ab(b64);
    return crypto.subtle.importKey('spki', spki, {name:'RSASSA-PKCS1-v1_5', hash:'SHA-256'}, true, ['verify']);
}

// Imports a private key from PEM format for signing
async function importSignPrivateKeyFromPem(pem) {
    const b64 = pemToBase64(pem);
    const pkcs8 = b642ab(b64);
    return crypto.subtle.importKey('pkcs8', pkcs8, {name:'RSASSA-PKCS1-v1_5', hash:'SHA-256'}, true, ['sign']);
}

// Exports a public key to PEM format
async function exportPublicKeyToPem(key) {
    const spki = await crypto.subtle.exportKey('spki', key);
    return toPem(ab2b64(spki), "PUBLIC KEY");
}

// Exports a private key to PEM format
async function exportPrivateKeyToPem(key) {
    const pkcs8 = await crypto.subtle.exportKey('pkcs8', key);
    return toPem(ab2b64(pkcs8), "PRIVATE KEY");
}

// DERIVE AES-GCM KEY FROM PASSPHRASE + SALT (PBKDF2)
// Derives an AES-GCM key using PBKDF2 from a passphrase and salt
async function deriveKey(passphrase, salt) {
    const enc = new TextEncoder();
    const baseKey = await crypto.subtle.importKey(
        "raw",
        enc.encode(passphrase),
        "PBKDF2",
        false,
        ["deriveKey"]
    );

    return crypto.subtle.deriveKey(
        {
            name: "PBKDF2",
            salt,
            iterations: 300000, // High iteration count for security
            hash: "SHA-256"
        },
        baseKey,
        { name: "AES-GCM", length: 256 }, // AES-256 key
        false,
        ["encrypt", "decrypt"]
    );
}

// Encrypts data using AES-GCM
async function aesGcmEncrypt(key, data) {
    const iv = crypto.getRandomValues(new Uint8Array(12)); // 96-bit IV recommended for AES-GCM
    const ciphertext = await crypto.subtle.encrypt({name:"AES-GCM", iv}, key, data);
    return { iv, ciphertext: new Uint8Array(ciphertext) };
}

// Decrypts data using AES-GCM
async function aesGcmDecrypt(key, iv, ciphertext) {
    return crypto.subtle.decrypt({name:"AES-GCM", iv}, key, ciphertext);
}

// RSA Key Generation (Enc + Sign)
// Generates RSA-OAEP (encryption) and RSASSA-PKCS1-v1_5 (signing) key pairs
async function generateRSAKeyPairs(modulusLength) {
    // Generate RSA-OAEP keys for encryption/decryption
    const encKeys = await crypto.subtle.generateKey(
        {
            name: "RSA-OAEP",
            modulusLength: modulusLength,
            publicExponent: new Uint8Array([1,0,1]), // 65537
            hash: "SHA-256"
        },
        true, // extractable
        ["encrypt", "decrypt"]
    );

    // Generate RSASSA-PKCS1-v1_5 keys for signing/verification
    const signKeys = await crypto.subtle.generateKey(
        {
            name: "RSASSA-PKCS1-v1_5",
            modulusLength: modulusLength,
            publicExponent: new Uint8Array([1,0,1]), // 65537
            hash: "SHA-256"
        },
        true, // extractable
        ["sign", "verify"]
    );
    return { encKeys, signKeys };
}

// EXPORT KEYS TO RAW BUFFERS (SPKI/PKCS8)
// Exports all key parts to raw Uint8Array buffers
async function exportAllKeysRaw(keys) {
    const encPubRaw = new Uint8Array(await crypto.subtle.exportKey("spki", keys.encKeys.publicKey));
    const encPrivRaw = new Uint8Array(await crypto.subtle.exportKey("pkcs8", keys.encKeys.privateKey));
    const signPubRaw = new Uint8Array(await crypto.subtle.exportKey("spki", keys.signKeys.publicKey));
    const signPrivRaw = new Uint8Array(await crypto.subtle.exportKey("pkcs8", keys.signKeys.privateKey));
    return { encPubRaw, encPrivRaw, signPubRaw, signPrivRaw };
}

// Combine keys as length-prefixed slices: [4-byte big endian length][bytes] x4
function combineRawKeys(...arrays) {
    let totalLength = arrays.reduce((acc, arr) => acc + arr.length + 4, 0); // +4 for length prefix
    let result = new Uint8Array(totalLength);
    let offset = 0;
    for(let arr of arrays){
        const length = arr.length;
        const view = new DataView(result.buffer);
        view.setUint32(offset, length, false); // false for big-endian
        offset += 4;
        result.set(arr, offset);
        offset += arr.length;
    }
    return result;
}

// Parses combined raw keys from a buffer
function parseCombinedRawKeys(buf) {
    let offset = 0;
    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);

    function readLength() {
        if (offset + 4 > buf.length) throw new Error("Invalid key data length (missing length prefix)");
        let len = view.getUint32(offset, false); // false for big-endian
        offset += 4;
        return len;
    }

    function readSlice(len) {
        if (offset + len > buf.length) throw new Error("Invalid key data length (slice too long)");
        let slice = buf.slice(offset, offset + len);
        offset += len;
        return slice;
    }

    const encPubRaw = readSlice(readLength());
    const encPrivRaw = readSlice(readLength());
    const signPubRaw = readSlice(readLength());
    const signPrivRaw = readSlice(readLength());
    return { encPubRaw, encPrivRaw, signPubRaw, signPrivRaw };
}

// Encrypt combined keys raw buffer with passphrase using AES-GCM (salt + iv prepended)
async function encryptKeysWithPassphrase(pass, combinedRawKeys) {
    const salt = crypto.getRandomValues(new Uint8Array(16)); // 16-byte salt
    const key = await deriveKey(pass, salt);
    const { iv, ciphertext } = await aesGcmEncrypt(key, combinedRawKeys);
    const encryptedBlob = concatArrays(salt, iv, ciphertext);
    return encryptedBlob;
}

// Decrypt keys blob with passphrase
async function decryptKeysWithPassphrase(pass, encryptedBlob) {
    if (encryptedBlob.length < 16 + 12) { // 16 bytes for salt, 12 for IV
        throw new Error("Encrypted keys blob too short.");
    }
    const salt = encryptedBlob.slice(0, 16);
    const iv = encryptedBlob.slice(16, 28);
    const ciphertext = encryptedBlob.slice(28);
    const key = await deriveKey(pass, salt);
    const rawKeysBuf = await aesGcmDecrypt(key, iv, ciphertext);
    return new Uint8Array(rawKeysBuf);
}

// Convert raw keys (Uint8Arrays) to PEM strings by base64 encoding + PEM formatting
function rawKeyToPem(rawKey, type) {
    return toPem(ab2b64(rawKey), type);
}

// Parse PEM string to raw Uint8Array buffer
function pemToRawKey(pem) {
    return new Uint8Array(b642ab(pemToBase64(pem)));
}

// Parse PEM textboxes to raw keys for export & encryption
function readKeysFromTextBoxes() {
    const pubPem = document.getElementById('publicKeyBox').value.trim();
    const privPem = document.getElementById('privateKeyBox').value.trim();

    if (!pubPem || !privPem) throw new Error("Your Public and Private key PEMs must not be empty for export.");

    // Assume these PEMs are encoding *encryption* keys
    const encPubRaw = pemToRawKey(pubPem);
    const encPrivRaw = pemToRawKey(privPem);

    // For simplicity, reuse same keys for signing (could separate)
    // So we will use same enc keys for sign keys to keep demo simple
    // Otherwise, you'd add additional textboxes or handling for sign keys
    const signPubRaw = encPubRaw;
    const signPrivRaw = encPrivRaw;
    return { encPubRaw, encPrivRaw, signPubRaw, signPrivRaw };
}

// Import your own keys freshly from PEM strings for encryption/signing operations
async function importYourKeysFromTextBoxes() {
    const pubPem = document.getElementById('publicKeyBox').value.trim();
    const privPem = document.getElementById('privateKeyBox').value.trim();
    if (!pubPem || !privPem) throw new Error("Your Public and Private key PEMs must not be empty.");

    // Import encryption keys
    const encPublicKey = await importPublicKeyFromPem(pubPem);
    const encPrivateKey = await importPrivateKeyFromPem(privPem);

    // Import signing keys same as enc keys here for simplicity (in real world separate)
    const signPublicKey = await importSignPublicKeyFromPem(pubPem);
    const signPrivateKey = await importSignPrivateKeyFromPem(privPem);
    return {
        encKeys: { publicKey: encPublicKey, privateKey: encPrivateKey },
        signKeys: { publicKey: signPublicKey, privateKey: signPrivateKey }
    };
}

// Encrypt and sign message string, reads YOUR private key and RECIPIENT's public key
async function encryptAndSignMessage(message) {
    const yourKeys = await importYourKeysFromTextBoxes();
    const recipientPubPem = document.getElementById('recipientPublicKeyBox').value.trim();

    if (!recipientPubPem) {
        throw new Error("Recipient's Public Key must be provided to encrypt the message.");
    }

    const recipientEncPublicKey = await importPublicKeyFromPem(recipientPubPem);

    const encoder = new TextEncoder();
    const messageBytes = encoder.encode(message);

    // Generate AES key
    const aesKey = await crypto.subtle.generateKey(
        {name:"AES-GCM", length:256}, true, ["encrypt", "decrypt"]);

    const iv = crypto.getRandomValues(new Uint8Array(12));

    // Encrypt message
    const ciphertext = new Uint8Array(await crypto.subtle.encrypt({name:"AES-GCM", iv}, aesKey, messageBytes));

    // Export AES key raw
    const rawAesKey = new Uint8Array(await crypto.subtle.exportKey("raw", aesKey));

    // Encrypt AES key with RECIPIENT's RSA-OAEP public key
    const encryptedAESKeyBuf = new Uint8Array(await crypto.subtle.encrypt({name:"RSA-OAEP"}, recipientEncPublicKey, rawAesKey));
    const encryptedAESKeyLength = encryptedAESKeyBuf.byteLength; // Store length of encrypted AES key

    // Sign original message with YOUR RSA private signing key
    const signatureBuf = new Uint8Array(await crypto.subtle.sign({name:"RSASSA-PKCS1-v1_5"}, yourKeys.signKeys.privateKey, messageBytes));
    const signatureLength = signatureBuf.byteLength; // Store length of signature

    // Prepend lengths as 4-byte big-endian integers
    const encryptedAESKeyLengthBytes = new Uint8Array(4);
    new DataView(encryptedAESKeyLengthBytes.buffer).setUint32(0, encryptedAESKeyLength, false);

    const signatureLengthBytes = new Uint8Array(4);
    new DataView(signatureLengthBytes.buffer).setUint32(0, signatureLength, false);

    // Concatenate: EncryptedAESKey_Length(4) + Signature_Length(4) + IV(12) + encryptedAESKey + ciphertext + signature
    const finalBlob = concatArrays(encryptedAESKeyLengthBytes, signatureLengthBytes, iv, encryptedAESKeyBuf, ciphertext, signatureBuf);
    return encodeBase64ToCustom(ab2b64(finalBlob), encoderAlphabet);
}

// Decrypt and verify message, reads YOUR private key and SENDER's public key (for verification)
async function decryptAndVerifyMessage(base64BlobEncoded) {
    const base64Blob = decodeCustomToBase64(base64BlobEncoded, encoderAlphabet)
    const yourKeys = await importYourKeysFromTextBoxes();
    const senderPubPem = document.getElementById('recipientPublicKeyBox').value.trim(); // Assuming recipient key box is used for sender's public key

    if (!senderPubPem) {
        throw new Error("Sender's Public Key must be provided to verify the signature.");
    }

    const senderSignPublicKey = await importSignPublicKeyFromPem(senderPubPem);

    const buf = new Uint8Array(b642ab(base64Blob));

    // Read encryptedAESKeyLength from the first 4 bytes
    if (buf.length < 4) {
        throw new Error("Invalid encrypted message length: missing encrypted AES key length.");
    }
    const encryptedAESKeyLength = new DataView(buf.buffer, buf.byteOffset, buf.byteLength).getUint32(0, false);

    // Read signatureLength from the next 4 bytes
    if (buf.length < 8) { // 4 bytes for encryptedAESKeyLength + 4 bytes for signatureLength
        throw new Error("Invalid encrypted message length: missing signature length.");
    }
    const signatureLength = new DataView(buf.buffer, buf.byteOffset, buf.byteLength).getUint32(4, false);


    const MIN_EXPECTED_LENGTH = 20 + encryptedAESKeyLength + signatureLength; // 4 for encKeyLen, 4 for sigLen, 12 for IV
    if (buf.length < MIN_EXPECTED_LENGTH) {
        throw new Error(`Invalid encrypted message length. Expected at least ${MIN_EXPECTED_LENGTH} bytes for encrypted AES key length ${encryptedAESKeyLength} and signature length ${signatureLength}, but got ${buf.length}.`);
    }

    let offset = 8; // Start after encryptedAESKeyLength and signatureLength

    const iv = buf.slice(offset, offset + 12);
    offset += 12;

    const encryptedAESKey = buf.slice(offset, offset + encryptedAESKeyLength);
    offset += encryptedAESKeyLength;

    // The signature is at the end of the combined buffer
    const signature = buf.slice(buf.length - signatureLength);
    // The ciphertext is everything between the end of encryptedAESKey and the start of the signature
    const ciphertext = buf.slice(offset, buf.length - signatureLength);

    // Decrypt AES key with YOUR RSA private key
    const rawAesKeyBuf = await crypto.subtle.decrypt({name:"RSA-OAEP"}, yourKeys.encKeys.privateKey, encryptedAESKey);

    const aesKey = await crypto.subtle.importKey("raw", rawAesKeyBuf, {name:"AES-GCM"}, false, ["decrypt"]);

    // Decrypt ciphertext
    const decryptedBuf = await crypto.subtle.decrypt({name:"AES-GCM", iv}, aesKey, ciphertext);

    // Verify signature on decrypted plaintext using SENDER's public key
    const verified = await crypto.subtle.verify(
        {name:"RSASSA-PKCS1-v1_5"},
        senderSignPublicKey,
        signature,
        decryptedBuf
    );

    const decoder = new TextDecoder();
    const decryptedText = decoder.decode(decryptedBuf);

    return { decryptedText, verified };
}

// Event Listeners for buttons
document.addEventListener('DOMContentLoaded', () => {
    // Store default states for elements
    const defaultStates = {
        genKeysBtn: {
            originalHTML: document.getElementById("genKeysBtn").innerHTML,
        },
        exportKeysBtn: {
            originalHTML: document.getElementById("exportKeysBtn").innerHTML,
        },
        importKeysBtn: {
            originalHTML: document.getElementById("importKeysBtn").innerHTML,
        },
        encryptBtn: {
            originalHTML: document.getElementById("encryptBtn").innerHTML,
        },
        decryptBtn: {
            originalHTML: document.getElementById("decryptBtn").innerHTML,
        },
        signatureVerificationResult: {
            textContent: "Verification status will appear here",
            className: "w-full p-3 border border-gray-300 dark:border-gray-700 rounded-md bg-gray-100 dark:bg-gray-900 font-mono text-sm",
        },
    };

    // Utility function to show a temporary message on a button
    function showTemporaryButtonMessage(button, originalHTML, message, duration = 3000) { // Default 3 seconds
        button.disabled = true;
        button.innerHTML = message;
        setTimeout(() => {
            button.innerHTML = originalHTML;
            button.disabled = false;
        }, duration);
    }

    // Generate keys and write PEM to text boxes (encryption and signing keys identical)
    document.getElementById("genKeysBtn").onclick = async () => {
        const genKeysBtn = document.getElementById("genKeysBtn");
        const keySizeInput = document.getElementById("keySizeInput");
        const resultBox = document.getElementById("resultBox");
        const signatureVerificationResult = document.getElementById("signatureVerificationResult");
        const publicKeyBox = document.getElementById("publicKeyBox");
        const privateKeyBox = document.getElementById("privateKeyBox");
        const encryptedKeysBox = document.getElementById("encryptedKeysBox");

        const modulusLength = parseInt(keySizeInput.value, 10);
        if (isNaN(modulusLength) || modulusLength < 1024 || modulusLength % 128 !== 0) {
            showTemporaryButtonMessage(genKeysBtn, defaultStates.genKeysBtn.originalHTML, '<i class="fas fa-exclamation-triangle mr-2"></i> Invalid Key Size (Must be multiple of 128)');
            return;
        }

        genKeysBtn.disabled = true;
        genKeysBtn.innerHTML = '<i class="fas fa-spinner animate-spin mr-2"></i> Generating keys...';

        try {
            // Pass the selected modulusLength to the generation function
            const keys = await generateRSAKeyPairs(modulusLength);

            // Export keys to PEM
            const pubPemEnc = await exportPublicKeyToPem(keys.encKeys.publicKey);
            const privPemEnc = await exportPrivateKeyToPem(keys.encKeys.privateKey);

            // For simplicity, use enc keys also as sign keys
            // Write to textareas
            publicKeyBox.value = pubPemEnc;
            privateKeyBox.value = privPemEnc;
            encryptedKeysBox.value = ""; // Clear exported keys when new keys are generated
            signatureVerificationResult.textContent = defaultStates.signatureVerificationResult.textContent;
            signatureVerificationResult.className = defaultStates.signatureVerificationResult.className;
            showTemporaryButtonMessage(genKeysBtn, defaultStates.genKeysBtn.originalHTML, `<i class="fas fa-check-circle mr-2"></i> Keys Generated!`);


        } catch (e) {
            signatureVerificationResult.textContent = defaultStates.signatureVerificationResult.textContent;
            signatureVerificationResult.className = defaultStates.signatureVerificationResult.className;
            showTemporaryButtonMessage(genKeysBtn, defaultStates.genKeysBtn.originalHTML, `<i class="fas fa-times-circle mr-2"></i> Generation Failed: ${e.message}`);
        }
    };

    // Export keys: read keys from textboxes, combine, encrypt with passphrase, output base64 blob
    document.getElementById("exportKeysBtn").onclick = async () => {
        const exportKeysBtn = document.getElementById("exportKeysBtn");
        const passphraseInput = document.getElementById("passphraseInput");
        const encryptedKeysBox = document.getElementById("encryptedKeysBox");
        const signatureVerificationResult = document.getElementById("signatureVerificationResult");

        const pass = passphraseInput.value;
        if (!pass) {
            encryptedKeysBox.value = "A passphrase is required to export keys.";
            signatureVerificationResult.textContent = defaultStates.signatureVerificationResult.textContent;
            signatureVerificationResult.className = defaultStates.signatureVerificationResult.className;
            return;
        }

        exportKeysBtn.disabled = true;
        exportKeysBtn.innerHTML = '<i class="fas fa-spinner animate-spin mr-2"></i> Encrypting keys...';

        try {
            const raw = readKeysFromTextBoxes();
            const combinedRaw = combineRawKeys(raw.encPubRaw, raw.encPrivRaw, raw.signPubRaw, raw.signPrivRaw);
            const encryptedBlob = await encryptKeysWithPassphrase(pass, combinedRaw);
            encryptedKeysBox.value = ab2b64(encryptedBlob);
            signatureVerificationResult.textContent = defaultStates.signatureVerificationResult.textContent;
            signatureVerificationResult.className = defaultStates.signatureVerificationResult.className;
            showDoneState(exportKeysBtn, defaultStates.exportKeysBtn.originalHTML);

        } catch(e) {
            encryptedKeysBox.value = "Export failed: " + e.message;
            signatureVerificationResult.textContent = defaultStates.signatureVerificationResult.textContent;
            signatureVerificationResult.className = defaultStates.signatureVerificationResult.className;
            exportKeysBtn.disabled = false;
            exportKeysBtn.innerHTML = defaultStates.exportKeysBtn.originalHTML;
        }
    };

    // Import keys: decrypt base64 blob with passphrase, parse keys, write PEM to textboxes
    document.getElementById("importKeysBtn").onclick = async () => {
        const importKeysBtn = document.getElementById("importKeysBtn");
        const passphraseInput = document.getElementById("passphraseInput");
        const encryptedKeysBox = document.getElementById("encryptedKeysBox");
        const publicKeyBox = document.getElementById("publicKeyBox");
        const privateKeyBox = document.getElementById("privateKeyBox");
        const signatureVerificationResult = document.getElementById("signatureVerificationResult");

        const pass = passphraseInput.value;
        const encryptedBase64 = encryptedKeysBox.value.trim();

        if (!encryptedBase64) {
            encryptedKeysBox.value = "Paste the encrypted keys in Base64 format to import.";
            signatureVerificationResult.textContent = defaultStates.signatureVerificationResult.textContent;
            signatureVerificationResult.className = defaultStates.signatureVerificationResult.className;
            return;
        }
         if (!pass) {
            encryptedKeysBox.value = "A passphrase is required to import keys.";
            signatureVerificationResult.textContent = defaultStates.signatureVerificationResult.textContent;
            signatureVerificationResult.className = defaultStates.signatureVerificationResult.className;
            return;
        }

        importKeysBtn.disabled = true;
        importKeysBtn.innerHTML = '<i class="fas fa-spinner animate-spin mr-2"></i> Decrypting keys...';

        try {
            const encryptedBlob = new Uint8Array(b642ab(encryptedBase64));
            const decryptedRaw = await decryptKeysWithPassphrase(pass, encryptedBlob);
            const { encPubRaw, encPrivRaw, signPubRaw, signPrivRaw } = parseCombinedRawKeys(decryptedRaw);

            // Convert raw to PEM strings
            const pubPem = rawKeyToPem(encPubRaw, "PUBLIC KEY");
            const privPem = rawKeyToPem(encPrivRaw, "PRIVATE KEY");

            // We ignore sign keys here, show encryption keys only
            publicKeyBox.value = pubPem;
            privateKeyBox.value = privPem;

            encryptedKeysBox.value = "Keys successfully decrypted and imported."; // Display success in the encryptedKeysBox
            signatureVerificationResult.textContent = defaultStates.signatureVerificationResult.textContent;
            signatureVerificationResult.className = defaultStates.signatureVerificationResult.className;
            showDoneState(importKeysBtn, defaultStates.importKeysBtn.originalHTML);


        } catch(e) {
            encryptedKeysBox.value = "Import failed. Please check the passphrase and data: " + e.message;
            signatureVerificationResult.textContent = defaultStates.signatureVerificationResult.textContent;
            signatureVerificationResult.className = defaultStates.signatureVerificationResult.className;
            importKeysBtn.disabled = false;
            importKeysBtn.innerHTML = defaultStates.importKeysBtn.originalHTML;
        }
    };

    // Encrypt message (read YOUR private key and RECIPIENT's public key)
    document.getElementById("encryptBtn").onclick = async () => {
        const encryptBtn = document.getElementById("encryptBtn");
        const messageBox = document.getElementById("messageBox");
        const resultBox = document.getElementById("resultBox");
        const signatureVerificationResult = document.getElementById("signatureVerificationResult");

        const msg = messageBox.value;
        if (!msg) {
            resultBox.value = "Please enter a message to encrypt.";
            signatureVerificationResult.textContent = defaultStates.signatureVerificationResult.textContent;
            signatureVerificationResult.className = defaultStates.signatureVerificationResult.className;
            return;
        }

        encryptBtn.disabled = true;
        encryptBtn.innerHTML = '<i class="fas fa-spinner animate-spin mr-2"></i> Encrypting...';

        try {
            const encrypted = await encryptAndSignMessage(msg);
            resultBox.value = encrypted;
            signatureVerificationResult.textContent = defaultStates.signatureVerificationResult.textContent;
            signatureVerificationResult.className = defaultStates.signatureVerificationResult.className;
            showDoneState(encryptBtn, defaultStates.encryptBtn.originalHTML);

        } catch(e) {
            resultBox.value = "Encryption failed: " + e.message;
            signatureVerificationResult.textContent = defaultStates.signatureVerificationResult.textContent;
            signatureVerificationResult.className = defaultStates.signatureVerificationResult.className;
            encryptBtn.disabled = false;
            encryptBtn.innerHTML = defaultStates.encryptBtn.originalHTML;
        }
    };

    // Decrypt message (read YOUR private key and SENDER's public key from recipient box)
    document.getElementById("decryptBtn").onclick = async () => {
        const decryptBtn = document.getElementById("decryptBtn");
        const messageBox = document.getElementById("messageBox");
        const resultBox = document.getElementById("resultBox");
        const signatureVerificationResult = document.getElementById("signatureVerificationResult");

        const blob = messageBox.value.trim();
        if (!blob) {
            resultBox.value = "Please enter the encrypted message in Base64 format to decrypt.";
            signatureVerificationResult.textContent = defaultStates.signatureVerificationResult.textContent;
            signatureVerificationResult.className = defaultStates.signatureVerificationResult.className;
            return;
        }

        decryptBtn.disabled = true;
        decryptBtn.innerHTML = '<i class="fas fa-spinner animate-spin mr-2"></i> Decrypting...';

        try {
            const { decryptedText, verified } = await decryptAndVerifyMessage(blob);
            resultBox.value = decryptedText;

            if (verified) {
                signatureVerificationResult.textContent = "Signature matches the recipient's public key ✅";
                signatureVerificationResult.className = "w-full p-3 border border-green-500 rounded-md bg-green-100 dark:bg-green-900 font-mono text-sm";
            } else {
                signatureVerificationResult.textContent = "Signature did not match recipient's public key ⚠️";
                signatureVerificationResult.className = "w-full p-3 border border-red-500 rounded-md bg-red-100 dark:bg-red-900 font-mono text-sm";
            }
            
            // Revert color after 1 second
            setTimeout(() => {
                signatureVerificationResult.className = defaultStates.signatureVerificationResult.className;
            }, 1000); // 1000 milliseconds = 1 second

            showDoneState(decryptBtn, defaultStates.decryptBtn.originalHTML);


        } catch(e) {
            resultBox.value = "Decryption or verification failed: " + e.message;
            signatureVerificationResult.textContent = defaultStates.signatureVerificationResult.textContent;
            signatureVerificationResult.className = defaultStates.signatureVerificationResult.className;
            decryptBtn.disabled = false;
            decryptBtn.innerHTML = defaultStates.decryptBtn.originalHTML;
        }
    };
});
